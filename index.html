<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Star Battle - Ece İçin</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @keyframes fall {
            to { transform: translateY(110vh) rotate(720deg); }
        }
        .touch-manipulation {
            touch-action: manipulation;
        }
        body {
            overscroll-behavior-y: none;
            background-color: #0f172a;
        }
    </style>
</head>
<body class="select-none text-slate-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // -- Simgeler --
        const RotateCcw = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /></svg>
        );
        const Trash2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>
        );
        const Plus = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></svg>
        );

        const StarBattle = () => {
            const [gridSize, setGridSize] = useState(5);
            const [grid, setGrid] = useState([]);
            const [history, setHistory] = useState([]);
            const [conflicts, setConflicts] = useState(new Set());
            const [solved, setSolved] = useState(false);
            const [shapes, setShapes] = useState([]);
            const [lastTap, setLastTap] = useState({ row: null, col: null, time: 0 });
            const [cellPlacementTime, setCellPlacementTime] = useState({});
            const [generating, setGenerating] = useState(true);

            // -- GİRİŞ EKRANI STATE'LERİ --
            const [introVisible, setIntroVisible] = useState(true);
            const [introFading, setIntroFading] = useState(false);

            useEffect(() => {
                const fadeTimer = setTimeout(() => { setIntroFading(true); }, 4500);
                const removeTimer = setTimeout(() => { setIntroVisible(false); }, 5500);
                return () => { clearTimeout(fadeTimer); clearTimeout(removeTimer); };
            }, []);

            // -- Benzersizlik Kontrolü --
            const countSolutions = (regionMap, size) => {
                let solutionCount = 0;
                const colUsed = new Array(size).fill(false);
                const regionUsed = new Array(size).fill(false);
                const placedStars = new Map(); 

                const search = (r) => {
                    if (solutionCount > 1) return; 
                    if (r === size) {
                        solutionCount++;
                        return;
                    }
                    for (let c = 0; c < size; c++) {
                        if (colUsed[c]) continue;
                        const reg = regionMap[r][c];
                        if (regionUsed[reg]) continue;
                        let conflict = false;
                        if (r > 0) {
                            const prevC = placedStars.get(r - 1);
                            if (Math.abs(prevC - c) <= 1) conflict = true;
                        }
                        if (!conflict) {
                            colUsed[c] = true;
                            regionUsed[reg] = true;
                            placedStars.set(r, c);
                            search(r + 1);
                            colUsed[c] = false;
                            regionUsed[reg] = false;
                            placedStars.delete(r);
                        }
                    }
                };
                search(0);
                return solutionCount;
            };

            const generateLevel = useCallback(() => {
                setGenerating(true);
                setTimeout(() => {
                    const size = gridSize;
                    let success = false;
                    let attempts = 0;
                    
                    while (!success && attempts < 200) {
                        attempts++;
                        try {
                            const placedStars = new Map(); 
                            const usedCols = new Set();
                            const solveLayout = (r) => {
                                if (r === size) return true; 
                                const validCols = [];
                                for (let c = 0; c < size; c++) {
                                    if (!usedCols.has(c)) {
                                        let touches = false;
                                        if (r > 0) {
                                            const prevC = placedStars.get(r - 1);
                                            if (Math.abs(prevC - c) <= 1) touches = true;
                                        }
                                        if (!touches) validCols.push(c);
                                    }
                                }
                                validCols.sort(() => Math.random() - 0.5);
                                for (const c of validCols) {
                                    placedStars.set(r, c);
                                    usedCols.add(c);
                                    if (solveLayout(r + 1)) return true;
                                    placedStars.delete(r);
                                    usedCols.delete(c);
                                }
                                return false;
                            };
                            if (!solveLayout(0)) continue;

                            const regionMap = Array(size).fill(null).map(() => Array(size).fill(-1));
                            const newShapes = Array(size).fill(null).map(() => []);
                            const queue = [];
                            for (let r = 0; r < size; r++) {
                                const c = placedStars.get(r);
                                if (c === undefined) throw new Error("Gen failed");
                                regionMap[r][c] = r;
                                newShapes[r].push([r, c]);
                                queue.push({ r, c, id: r });
                            }
                            while (queue.length > 0) {
                                const randIdx = Math.floor(Math.random() * queue.length);
                                const { r, c, id } = queue.splice(randIdx, 1)[0];
                                const neighbors = [[r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]];
                                for (const [nr, nc] of neighbors) {
                                    if (nr >= 0 && nr < size && nc >= 0 && nc < size && regionMap[nr][nc] === -1) {
                                        regionMap[nr][nc] = id;
                                        newShapes[id].push([nr, nc]);
                                        queue.push({ r: nr, c: nc, id });
                                    }
                                }
                            }
                            for (let r = 0; r < size; r++) {
                                for (let c = 0; c < size; c++) {
                                    if (regionMap[r][c] === -1) {
                                        let filled = false;
                                        const neighbors = [[r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]];
                                        for (const [nr, nc] of neighbors) {
                                            if (nr >= 0 && nr < size && nc >= 0 && nc < size && regionMap[nr][nc] !== -1) {
                                                const neighborId = regionMap[nr][nc];
                                                regionMap[r][c] = neighborId;
                                                newShapes[neighborId].push([r, c]);
                                                filled = true;
                                                break;
                                            }
                                        }
                                        if (!filled) {
                                             regionMap[r][c] = 0;
                                             newShapes[0].push([r, c]);
                                        }
                                    }
                                }
                            }
                            if (countSolutions(regionMap, size) === 1) {
                                setShapes(newShapes);
                                success = true;
                            }
                        } catch (e) {}
                    }
                    const emptyGrid = Array(size).fill(null).map(() => 
                        Array(size).fill(null).map(() => ({ state: 'empty', manualCross: false }))
                    );
                    setGrid(emptyGrid);
                    setHistory([]);
                    setConflicts(new Set());
                    setSolved(false);
                    setCellPlacementTime({});
                    setGenerating(false);
                }, 10);
            }, [gridSize]);

            useEffect(() => {
                generateLevel();
            }, [generateLevel]);

            const checkConflicts = (testGrid) => {
                const newConflicts = new Set();
                const size = testGrid.length; 
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (testGrid[r][c].state === 'star') {
                            for (let c2 = c + 1; c2 < size; c2++) if (testGrid[r][c2].state === 'star') { newConflicts.add(`${r},${c}`); newConflicts.add(`${r},${c2}`); }
                            for (let r2 = r + 1; r2 < size; r2++) if (testGrid[r2][c].state === 'star') { newConflicts.add(`${r},${c}`); newConflicts.add(`${r2},${c}`); }
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    const nr = r + dr, nc = c + dc;
                                    if (nr >= 0 && nr < size && nc >= 0 && nc < size && testGrid[nr][nc].state === 'star') {
                                        newConflicts.add(`${r},${c}`); newConflicts.add(`${nr},${nc}`);
                                    }
                                }
                            }
                        }
                    }
                }
                return newConflicts;
            };

            useEffect(() => {
                if (grid.length === 0 || grid.length !== gridSize || solved) return;
                const currentConflicts = checkConflicts(grid);
                if (currentConflicts.size > 0) return;
                
                let starCount = 0;
                for (let r = 0; r < gridSize; r++) for (let c = 0; c < gridSize; c++) if (grid[r][c].state === 'star') starCount++;
                if (starCount !== gridSize) return;

                for (let r = 0; r < gridSize; r++) if (grid[r].filter(c => c.state === 'star').length !== 1) return;
                for (let c = 0; c < gridSize; c++) if (grid.map(row => row[c]).filter(cell => cell.state === 'star').length !== 1) return;
                for (let i = 0; i < shapes.length; i++) if (shapes[i].length > 0 && shapes[i].filter(([r, c]) => grid[r][c].state === 'star').length !== 1) return;

                setSolved(true);
            }, [grid, conflicts, gridSize, shapes, solved]);

            const handleCellClick = (row, col) => {
                if (solved || generating || introVisible) return;
                const now = Date.now();
                const timeDiff = now - lastTap.time;
                const isDouble = lastTap.row === row && lastTap.col === col && timeDiff < 300;
                const cellKey = `${row}-${col}`;
                const placeTime = now - (cellPlacementTime[cellKey] || 0);

                setLastTap({ row, col, time: now });
                setHistory([...history, JSON.parse(JSON.stringify(grid))]);

                const newGrid = grid.map(row => row.map(cell => ({ ...cell })));
                const cell = newGrid[row][col];

                if (cell.state === 'empty') {
                    if (isDouble) {
                        cell.state = 'star';
                        cell.manualCross = false;
                        autoFill(newGrid, row, col);
                        setCellPlacementTime({ ...cellPlacementTime, [cellKey]: now });
                    } else {
                        cell.state = 'cross';
                        cell.manualCross = true;
                        setCellPlacementTime({ ...cellPlacementTime, [cellKey]: now });
                    }
                } else if (cell.state === 'cross') {
                    if (placeTime < 300) {
                        cell.state = 'star';
                        cell.manualCross = false;
                        autoFill(newGrid, row, col);
                        setCellPlacementTime({ ...cellPlacementTime, [cellKey]: now });
                    } else {
                        cell.state = 'empty';
                    }
                } else if (cell.state === 'star') {
                    cell.state = 'empty';
                    clearAuto(newGrid, row, col);
                }
                setGrid(newGrid);
                setConflicts(checkConflicts(newGrid));
            };

            const autoFill = (g, r, c) => {
                const s = g.length;
                for (let i = 0; i < s; i++) {
                    if (i !== c && g[r][i].state === 'empty') { g[r][i].state = 'cross'; g[r][i].manualCross = false; }
                    if (i !== r && g[i][c].state === 'empty') { g[i][c].state = 'cross'; g[i][c].manualCross = false; }
                }
            };
            const clearAuto = (g, r, c) => {
                const s = g.length;
                for (let i = 0; i < s; i++) {
                    if (i !== c && g[r][i].state === 'cross' && !g[r][i].manualCross) g[r][i].state = 'empty';
                    if (i !== r && g[i][c].state === 'cross' && !g[i][c].manualCross) g[i][c].state = 'empty';
                }
            };

            const getShapeColor = (r, c) => {
                const colors = ['bg-blue-100', 'bg-emerald-100', 'bg-amber-100', 'bg-purple-100', 'bg-rose-100', 'bg-cyan-100', 'bg-lime-100'];
                for (let i = 0; i < shapes.length; i++) if (shapes[i].some(([sr, sc]) => sr === r && sc === c)) return colors[i % colors.length];
                return 'bg-white';
            };
            const getShapeBorder = (r, c) => {
                let sIdx = -1;
                for (let i = 0; i < shapes.length; i++) if (shapes[i].some(([sr, sc]) => sr === r && sc === c)) { sIdx = i; break; }
                if (sIdx === -1) return '';
                const s = shapes[sIdx];
                const isIn = (nr, nc) => s.some(([sr, sc]) => sr === nr && sc === nc);
                return `${!isIn(r-1, c)?'border-t-4':''} ${!isIn(r+1, c)?'border-b-4':''} ${!isIn(r, c-1)?'border-l-4':''} ${!isIn(r, c+1)?'border-r-4':''}`;
            };

            return (
                <div className="relative min-h-[100dvh] flex items-center justify-center p-2 sm:p-4 bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 overflow-hidden">
                    
                    {/* GİRİŞ EKRANI */}
                    {introVisible && (
                        <div className={`fixed inset-0 z-[100] flex items-center justify-center bg-slate-900 transition-opacity duration-1000 ${introFading ? 'opacity-0' : 'opacity-100'}`}>
                            <h1 className="text-4xl sm:text-6xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 text-center px-4 animate-pulse leading-tight">
                                ece seni çok seviyorum
                            </h1>
                        </div>
                    )}

                    {/* OYUN ALANI */}
                    <div className={`bg-white rounded-xl shadow-2xl p-4 sm:p-8 w-full max-w-md relative flex flex-col items-center transition-opacity duration-1000 ${introVisible ? 'opacity-0' : 'opacity-100'}`}>
                        {generating && !introVisible && (
                            <div className="absolute inset-0 bg-white/90 z-50 flex flex-col items-center justify-center rounded-xl">
                                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-purple-600 mb-4"></div>
                                <p className="font-semibold text-purple-600">Benzersiz Seviye Oluşturuluyor...</p>
                            </div>
                        )}
                        
                        <h1 className="text-2xl sm:text-3xl font-bold text-center mb-1 text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-pink-600">Star Battle</h1>
                        <p className="text-center text-gray-500 mb-4 text-xs sm:text-sm">Yıldız koymak için çift dokun ★</p>
                        
                        <div className="flex justify-center gap-2 mb-4 w-full">
                            {[5, 6, 7].map(s => (
                                <button key={s} onClick={() => setGridSize(s)} disabled={solved || generating} 
                                    className={`flex-1 py-2 rounded-lg font-bold text-sm transition-all touch-manipulation
                                    ${gridSize === s ? 'bg-purple-600 text-white shadow-lg' : 'bg-gray-100 text-gray-700 active:bg-gray-200'} 
                                    ${solved?'opacity-50':''}`}>
                                    {s}×{s}
                                </button>
                            ))}
                        </div>

                        <div className="mb-6 w-full max-w-[350px]">
                            <div className="grid gap-0 border-4 border-gray-800 rounded-lg overflow-hidden bg-gray-800 shadow-xl"
                                style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)` }}>
                                {grid.length === gridSize && grid.map((row, r) => row.map((cell, c) => {
                                    const isConflict = conflicts.has(`${r},${c}`);
                                    return (
                                        <div key={`${r}-${c}`} 
                                            onPointerDown={(e) => { e.preventDefault(); handleCellClick(r, c); }}
                                            className={`
                                                aspect-square w-full
                                                border border-gray-300 flex items-center justify-center 
                                                text-xl sm:text-2xl font-bold cursor-pointer transition-colors duration-150 touch-manipulation select-none
                                                ${getShapeColor(r, c)} ${getShapeBorder(r, c)} border-gray-700 
                                                ${isConflict?'bg-red-300 animate-pulse':''} 
                                                ${!solved?'active:brightness-90':''}
                                            `}>
                                            {/* YILDIZ RENGİ BURADA DEĞİŞTİRİLDİ: text-yellow-500 */}
                                            {cell.state === 'star' && <span className="drop-shadow-sm transform scale-125 text-yellow-500">★</span>}
                                            {cell.state === 'cross' && <span className="text-red-500 opacity-60 text-lg">✕</span>}
                                        </div>
                                    );
                                }))}
                            </div>
                        </div>

                        <div className="flex gap-2 w-full max-w-[350px]">
                            <button onClick={() => { if(history.length) { setGrid(history[history.length-1]); setHistory(history.slice(0,-1)); setConflicts(checkConflicts(history[history.length-1])); setSolved(false); }}} 
                                disabled={!history.length || solved || generating} 
                                className="flex-1 flex items-center justify-center gap-1 py-3 bg-blue-600 text-white rounded-lg disabled:bg-gray-200 disabled:text-gray-400 touch-manipulation active:scale-95 transition-transform">
                                <RotateCcw size={18}/><span className="text-sm font-semibold">Geri Al</span>
                            </button>
                            <button onClick={() => { setGrid(grid.map(r => r.map(() => ({state:'empty', manualCross:false})))); setHistory([]); setConflicts(new Set()); setSolved(false); }} 
                                disabled={solved || generating} 
                                className="flex-1 flex items-center justify-center gap-1 py-3 bg-orange-600 text-white rounded-lg disabled:bg-gray-200 disabled:text-gray-400 touch-manipulation active:scale-95 transition-transform">
                                <Trash2 size={18}/><span className="text-sm font-semibold">Temizle</span>
                            </button>
                            <button onClick={generateLevel} disabled={generating} 
                                className="flex-1 flex items-center justify-center gap-1 py-3 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 disabled:bg-emerald-400 touch-manipulation active:scale-95 transition-transform shadow-md">
                                <Plus size={18}/><span className="text-sm font-semibold">Yeni</span>
                            </button>
                        </div>

                        {solved && <div className="mt-4 text-center animate-bounce text-2xl font-bold text-green-600 drop-shadow-sm">Bulmaca Çözüldü!</div>}
                        {solved && <div className="fixed inset-0 pointer-events-none z-50 overflow-hidden">{[...Array(50)].map((_, i) => <div key={i} className="absolute text-2xl" style={{left: `${Math.random()*100}%`, top: '-50px', animation: `fall ${2+Math.random()*3}s linear ${Math.random()*2}s infinite`}}>★</div>)}</div>}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<StarBattle />);
    </script>
</body>
</html>
