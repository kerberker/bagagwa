<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Battle</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @keyframes fall {
            to { transform: translateY(110vh) rotate(720deg); }
        }
    </style>
</head>
<body class="bg-slate-900 select-none text-slate-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // -- Icons --
        const RotateCcw = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12" /><path d="M3 3v9h9" /></svg>
        );
        const Trash2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>
        );
        const Plus = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></svg>
        );

        const StarBattle = () => {
            const [gridSize, setGridSize] = useState(5);
            const [grid, setGrid] = useState([]);
            const [history, setHistory] = useState([]);
            const [conflicts, setConflicts] = useState(new Set());
            const [solved, setSolved] = useState(false);
            const [shapes, setShapes] = useState([]);
            const [lastTap, setLastTap] = useState({ row: null, col: null, time: 0 });
            const [cellPlacementTime, setCellPlacementTime] = useState({});
            const [generating, setGenerating] = useState(true);

            // -- NEW: Uniqueness Checker --
            const countSolutions = (regionMap, size) => {
                let solutionCount = 0;
                const colUsed = new Array(size).fill(false);
                const regionUsed = new Array(size).fill(false);
                const placedStars = new Map(); // r -> c

                const search = (r) => {
                    // Optimization: If we found more than 1 solution, stop searching.
                    // The puzzle is already "ambiguous" and invalid.
                    if (solutionCount > 1) return; 

                    if (r === size) {
                        solutionCount++;
                        return;
                    }

                    for (let c = 0; c < size; c++) {
                        // Check Constraints: Col, Region, Adjacency
                        if (colUsed[c]) continue;
                        
                        const reg = regionMap[r][c];
                        if (regionUsed[reg]) continue;

                        let conflict = false;
                        if (r > 0) {
                            const prevC = placedStars.get(r - 1);
                            if (Math.abs(prevC - c) <= 1) conflict = true;
                        }

                        if (!conflict) {
                            // Place Star
                            colUsed[c] = true;
                            regionUsed[reg] = true;
                            placedStars.set(r, c);

                            search(r + 1);

                            // Backtrack
                            colUsed[c] = false;
                            regionUsed[reg] = false;
                            placedStars.delete(r);
                        }
                    }
                };

                search(0);
                return solutionCount;
            };

            const generateLevel = useCallback(() => {
                setGenerating(true);
                // Use setTimeout to allow UI to show "Generating..." state
                setTimeout(() => {
                    const size = gridSize;
                    let success = false;
                    let attempts = 0;
                    
                    while (!success && attempts < 200) {
                        attempts++;
                        try {
                            const placedStars = new Map(); 
                            const usedCols = new Set();

                            // 1. Generate a valid star layout
                            const solveLayout = (r) => {
                                if (r === size) return true; 
                                const validCols = [];
                                for (let c = 0; c < size; c++) {
                                    if (!usedCols.has(c)) {
                                        let touches = false;
                                        if (r > 0) {
                                            const prevC = placedStars.get(r - 1);
                                            if (Math.abs(prevC - c) <= 1) touches = true;
                                        }
                                        if (!touches) validCols.push(c);
                                    }
                                }
                                validCols.sort(() => Math.random() - 0.5);
                                for (const c of validCols) {
                                    placedStars.set(r, c);
                                    usedCols.add(c);
                                    if (solveLayout(r + 1)) return true;
                                    placedStars.delete(r);
                                    usedCols.delete(c);
                                }
                                return false;
                            };

                            if (!solveLayout(0)) continue;

                            // 2. Generate Regions
                            const regionMap = Array(size).fill(null).map(() => Array(size).fill(-1));
                            const newShapes = Array(size).fill(null).map(() => []);
                            const queue = [];

                            for (let r = 0; r < size; r++) {
                                const c = placedStars.get(r);
                                if (c === undefined) throw new Error("Gen failed");
                                regionMap[r][c] = r;
                                newShapes[r].push([r, c]);
                                queue.push({ r, c, id: r });
                            }

                            // Grow Regions
                            while (queue.length > 0) {
                                const randIdx = Math.floor(Math.random() * queue.length);
                                const { r, c, id } = queue.splice(randIdx, 1)[0];
                                const neighbors = [[r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]];

                                for (const [nr, nc] of neighbors) {
                                    if (nr >= 0 && nr < size && nc >= 0 && nc < size && regionMap[nr][nc] === -1) {
                                        regionMap[nr][nc] = id;
                                        newShapes[id].push([nr, nc]);
                                        queue.push({ r: nr, c: nc, id });
                                    }
                                }
                            }

                            // Fill remaining holes
                            for (let r = 0; r < size; r++) {
                                for (let c = 0; c < size; c++) {
                                    if (regionMap[r][c] === -1) {
                                        // Simple fill: assign to nearest neighbor or default to 0
                                        let filled = false;
                                        const neighbors = [[r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]];
                                        for (const [nr, nc] of neighbors) {
                                            if (nr >= 0 && nr < size && nc >= 0 && nc < size && regionMap[nr][nc] !== -1) {
                                                const neighborId = regionMap[nr][nc];
                                                regionMap[r][c] = neighborId;
                                                newShapes[neighborId].push([r, c]);
                                                filled = true;
                                                break;
                                            }
                                        }
                                        if (!filled) {
                                             regionMap[r][c] = 0;
                                             newShapes[0].push([r, c]);
                                        }
                                    }
                                }
                            }

                            // 3. CRITICAL: Check Uniqueness
                            // Count how many solutions exist for this specific region map
                            const solutions = countSolutions(regionMap, size);
                            
                            if (solutions === 1) {
                                setShapes(newShapes);
                                success = true;
                            } else {
                                // If 0 solutions (impossible) or >1 (ambiguous), discard and retry
                                // console.log(`Discarded puzzle with ${solutions} solutions`);
                            }

                        } catch (e) {
                            console.warn("Retrying generation...", e);
                        }
                    }

                    // Reset Grid
                    const emptyGrid = Array(size).fill(null).map(() => 
                        Array(size).fill(null).map(() => ({ state: 'empty', manualCross: false }))
                    );
                    setGrid(emptyGrid);
                    setHistory([]);
                    setConflicts(new Set());
                    setSolved(false);
                    setCellPlacementTime({});
                    setGenerating(false);
                }, 10);
            }, [gridSize]);

            useEffect(() => {
                generateLevel();
            }, [generateLevel]);

            // -- Logic Helpers --
            const checkConflicts = (testGrid) => {
                const newConflicts = new Set();
                const size = testGrid.length; 
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (testGrid[r][c].state === 'star') {
                            for (let c2 = c + 1; c2 < size; c2++) if (testGrid[r][c2].state === 'star') { newConflicts.add(`${r},${c}`); newConflicts.add(`${r},${c2}`); }
                            for (let r2 = r + 1; r2 < size; r2++) if (testGrid[r2][c].state === 'star') { newConflicts.add(`${r},${c}`); newConflicts.add(`${r2},${c}`); }
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    const nr = r + dr, nc = c + dc;
                                    if (nr >= 0 && nr < size && nc >= 0 && nc < size && testGrid[nr][nc].state === 'star') {
                                        newConflicts.add(`${r},${c}`); newConflicts.add(`${nr},${nc}`);
                                    }
                                }
                            }
                        }
                    }
                }
                return newConflicts;
            };

            useEffect(() => {
                if (grid.length === 0 || grid.length !== gridSize || solved) return;
                
                const currentConflicts = checkConflicts(grid);
                if (currentConflicts.size > 0) return;
                
                let starCount = 0;
                for (let r = 0; r < gridSize; r++) for (let c = 0; c < gridSize; c++) if (grid[r][c].state === 'star') starCount++;
                if (starCount !== gridSize) return;

                for (let r = 0; r < gridSize; r++) if (grid[r].filter(c => c.state === 'star').length !== 1) return;
                for (let c = 0; c < gridSize; c++) if (grid.map(row => row[c]).filter(cell => cell.state === 'star').length !== 1) return;
                for (let i = 0; i < shapes.length; i++) if (shapes[i].length > 0 && shapes[i].filter(([r, c]) => grid[r][c].state === 'star').length !== 1) return;

                setSolved(true);
            }, [grid, conflicts, gridSize, shapes, solved]);

            const handleCellClick = (row, col) => {
                if (solved || generating) return;
                const now = Date.now();
                const timeDiff = now - lastTap.time;
                const isDouble = lastTap.row === row && lastTap.col === col && timeDiff < 300;
                const cellKey = `${row}-${col}`;
                const placeTime = now - (cellPlacementTime[cellKey] || 0);

                setLastTap({ row, col, time: now });
                setHistory([...history, JSON.parse(JSON.stringify(grid))]);

                const newGrid = grid.map(row => row.map(cell => ({ ...cell })));
                const cell = newGrid[row][col];

                if (cell.state === 'empty') {
                    if (isDouble) {
                        cell.state = 'star';
                        cell.manualCross = false;
                        autoFill(newGrid, row, col);
                        setCellPlacementTime({ ...cellPlacementTime, [cellKey]: now });
                    } else {
                        cell.state = 'cross';
                        cell.manualCross = true;
                        setCellPlacementTime({ ...cellPlacementTime, [cellKey]: now });
                    }
                } else if (cell.state === 'cross') {
                    if (placeTime < 300) {
                        cell.state = 'star';
                        cell.manualCross = false;
                        autoFill(newGrid, row, col);
                        setCellPlacementTime({ ...cellPlacementTime, [cellKey]: now });
                    } else {
                        cell.state = 'empty';
                    }
                } else if (cell.state === 'star') {
                    cell.state = 'empty';
                    clearAuto(newGrid, row, col);
                }
                setGrid(newGrid);
                setConflicts(checkConflicts(newGrid));
            };

            const autoFill = (g, r, c) => {
                const s = g.length;
                for (let i = 0; i < s; i++) {
                    if (i !== c && g[r][i].state === 'empty') { g[r][i].state = 'cross'; g[r][i].manualCross = false; }
                    if (i !== r && g[i][c].state === 'empty') { g[i][c].state = 'cross'; g[i][c].manualCross = false; }
                }
            };
            const clearAuto = (g, r, c) => {
                const s = g.length;
                for (let i = 0; i < s; i++) {
                    if (i !== c && g[r][i].state === 'cross' && !g[r][i].manualCross) g[r][i].state = 'empty';
                    if (i !== r && g[i][c].state === 'cross' && !g[i][c].manualCross) g[i][c].state = 'empty';
                }
            };

            const getShapeColor = (r, c) => {
                const colors = ['bg-blue-100', 'bg-emerald-100', 'bg-amber-100', 'bg-purple-100', 'bg-rose-100', 'bg-cyan-100', 'bg-lime-100'];
                for (let i = 0; i < shapes.length; i++) if (shapes[i].some(([sr, sc]) => sr === r && sc === c)) return colors[i % colors.length];
                return 'bg-white';
            };
            const getShapeBorder = (r, c) => {
                let sIdx = -1;
                for (let i = 0; i < shapes.length; i++) if (shapes[i].some(([sr, sc]) => sr === r && sc === c)) { sIdx = i; break; }
                if (sIdx === -1) return '';
                const s = shapes[sIdx];
                const isIn = (nr, nc) => s.some(([sr, sc]) => sr === nr && sc === nc);
                return `${!isIn(r-1, c)?'border-t-4':''} ${!isIn(r+1, c)?'border-b-4':''} ${!isIn(r, c-1)?'border-l-4':''} ${!isIn(r, c+1)?'border-r-4':''}`;
            };

            return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 max-w-2xl w-full text-slate-900 relative">
                        {generating && (
                            <div className="absolute inset-0 bg-white/80 z-50 flex flex-col items-center justify-center rounded-2xl">
                                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600 mb-4"></div>
                                <p className="font-semibold text-purple-600">Generating Unique Puzzle...</p>
                            </div>
                        )}
                        
                        <h1 className="text-3xl font-bold text-center mb-2 text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-pink-600">Star Battle</h1>
                        <p className="text-center text-gray-500 mb-6 text-sm">1 star per row, column, and color.</p>
                        
                        <div className="flex justify-center gap-2 mb-6">
                            {[5, 6, 7].map(s => (
                                <button key={s} onClick={() => setGridSize(s)} disabled={solved || generating} 
                                    className={`px-4 py-2 rounded-lg font-semibold transition-all text-sm ${gridSize === s ? 'bg-purple-600 text-white shadow-lg' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'} ${solved?'opacity-50':''}`}>
                                    {s}×{s}
                                </button>
                            ))}
                        </div>

                        <div className="mb-6 flex justify-center select-none">
                            <div className="inline-grid gap-0 border-4 border-gray-800 rounded-lg overflow-hidden bg-gray-800"
                                style={{ gridTemplateColumns: `repeat(${gridSize}, minmax(0, 1fr))` }}>
                                {grid.length === gridSize && grid.map((row, r) => row.map((cell, c) => {
                                    const isConflict = conflicts.has(`${r},${c}`);
                                    return (
                                        <div key={`${r}-${c}`} onMouseDown={(e) => { e.preventDefault(); handleCellClick(r, c); }}
                                            className={`w-10 h-10 sm:w-14 sm:h-14 border border-gray-300 flex items-center justify-center text-xl font-bold cursor-pointer transition-colors duration-150 ${getShapeColor(r, c)} ${getShapeBorder(r, c)} border-gray-700 ${isConflict?'bg-red-300 animate-pulse':''} ${!solved?'hover:brightness-95':''}`}>
                                            {cell.state === 'star' && '★'}
                                            {cell.state === 'cross' && <span className="text-red-500 opacity-60 text-sm">✕</span>}
                                        </div>
                                    );
                                }))}
                            </div>
                        </div>

                        <div className="flex gap-3 justify-center">
                            <button onClick={() => { if(history.length) { setGrid(history[history.length-1]); setHistory(history.slice(0,-1)); setConflicts(checkConflicts(history[history.length-1])); setSolved(false); }}} 
                                disabled={!history.length || solved || generating} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg disabled:bg-gray-200 disabled:text-gray-400"><RotateCcw size={18}/>Undo</button>
                            <button onClick={() => { setGrid(grid.map(r => r.map(() => ({state:'empty', manualCross:false})))); setHistory([]); setConflicts(new Set()); setSolved(false); }} 
                                disabled={solved || generating} className="flex items-center gap-2 px-4 py-2 bg-orange-600 text-white rounded-lg disabled:bg-gray-200 disabled:text-gray-400"><Trash2 size={18}/>Clear</button>
                            <button onClick={generateLevel} disabled={generating} className="flex items-center gap-2 px-4 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 disabled:bg-emerald-400"><Plus size={18}/>New</button>
                        </div>

                        {solved && <div className="mt-6 text-center animate-bounce text-2xl font-bold text-green-600">Puzzle Solved!</div>}
                        {solved && <div className="fixed inset-0 pointer-events-none z-50 overflow-hidden">{[...Array(50)].map((_, i) => <div key={i} className="absolute text-2xl" style={{left: `${Math.random()*100}%`, top: '-50px', animation: `fall ${2+Math.random()*3}s linear ${Math.random()*2}s infinite`}}>★</div>)}</div>}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<StarBattle />);
    </script>
</body>
</html>
